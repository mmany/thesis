# -*- coding: utf-8 -*-
"""NigPC_fun.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JGPHZ97QmmyW-GK2XtZkah4HEZtU7f_r
"""

import numpy as np
from numpy.linalg import eig
from scipy import stats
from scipy.stats import uniform
from scipy.integrate import quad
import scipy.stats
import matplotlib.pyplot as plt

def NigPC(u0 ,std, OrderPol,Dimension, a,b,tol):
  pd = uniform(loc = a, scale = b-a)
  print('bounds of distribution lower: %s, upper: %s' % pd.support())
  Poly = 'legendre_st'
  def local_basis_Stieltjes_test(prob_dens,a,b,order,tol):
  # Initialize low-order recursion coefficients and basis functions
    basis_fun = np.empty(order+1,dtype=object)
    alpha = np.empty(order+1,dtype=float)
    beta = np.empty(order+1,dtype=float)
    basis_fun[0] = lambda xi: xi**0*(xi>=a)*(xi<=b) # The zeroth order basis fcn is always 1 (o.w. not a pdf)
    alpha[0] = quad(lambda xi:prob_dens.pdf(xi)*xi,a,b,epsabs = tol)[0]/quad(lambda xi:prob_dens.pdf(xi)*basis_fun[0](xi)**2,a,b,epsabs=tol)[0]
    beta[0] = quad(lambda xi:prob_dens.pdf(xi),a,b,epsabs=tol)[0]
    
    #print(prob_dens.pdf(-1)*basis_fun[0](-1)**2,prob_dens.pdf(0)*basis_fun[0](0)**2)
    #print(quad(lambda xi:prob_dens.pdf(xi)*xi*basis_fun[0](xi)**2,a,b,epsabs=tol)[0])
    #x= np.linspace(-1,1,100)
    #f = lambda xi:prob_dens.pdf(xi)*(basis_fun[0](xi))**2
    #plt.figure()
    #plt.plot(x,f(x))
    basis_fun[1] = lambda xi: xi-alpha[0]
    #% % basis_fun{2} = @(xi) basis_fun{2}(xi)./beta(3).*(xi>=a).*(xi<=b);
    alpha[1] = quad(lambda xi:prob_dens.pdf(xi)*xi*basis_fun[1](xi)**2,a,b,epsabs=tol)[0]/quad(lambda xi:prob_dens.pdf(xi)*basis_fun[1](xi)**2,a,b,epsabs=tol)[0]
    #%beta(2) = sqrt(quadgk(@(xi) prob_dens(xi).*basis_fun{1}(xi).^2,a,b,'AbsTol',tol));
    beta[1] = quad(lambda xi:prob_dens.pdf(xi)*basis_fun[1](xi)**2,a,b,epsabs=tol)[0]/quad(lambda xi:prob_dens.pdf(xi)*basis_fun[0](xi)**2,a,b,epsabs=tol)[0]
    #% Recursive computation of alpha, beta, and basis functions
    for k in range(2,order+1):
        basis_fun[k] = lambda xi,k=k: (xi-alpha[k-1])*basis_fun[k-1](xi)-beta[k-1]*basis_fun[k-2](xi)
        alpha[k] = quad(lambda xi,k=k:prob_dens.pdf(xi)*xi*basis_fun[k](xi)**2,a,b,epsabs=tol)[0]/quad(lambda xi,k=k:prob_dens.pdf(xi)*basis_fun[k](xi)**2,a,b,epsabs=tol)[0]
        beta[k] = quad(lambda xi,k=k:prob_dens.pdf(xi)*basis_fun[k](xi)**2,a,b,epsabs=tol)[0]/ quad(lambda xi,k=k:prob_dens.pdf(xi)*basis_fun[k-1](xi)**2,a,b,epsabs=tol)[0]

    basis_fun_vec = np.empty_like(basis_fun);
    normal_scaling = 1/np.sqrt(np.cumprod(beta));
    for k in range(order+1):
        basis_fun_vec[k] = lambda xi, k=k: normal_scaling[k]*basis_fun[k](xi)
    
    return basis_fun_vec, alpha, beta
  def quad_from_alpha_beta(alpha,beta):
    n = len(alpha);
    J = np.zeros((n,n))
    for i in range(n):
      J[i,i] = alpha[i]
      if i<(n-1):
          J[i,i+1] = np.sqrt(beta[i+1])
          J[i+1,i] = np.sqrt(beta[i+1])


    #% Jacobi matrix should be symmetric by construction, but small errors makes
    #% it inexact, therefore: 
    J = (J+J.T)/2;

    eigval, eigvec = eig(J);

    #% Gauss-type quadrature nodes and weights
    nodes = eigval
    weights = eigvec[1,:]**2
    return nodes, weights
  basis_fun_vec = np.empty((OrderPol+1,1),dtype=object)
  alpha_coe =np.empty((OrderPol+1,1),dtype=float)
  beta_coe = np.empty((OrderPol+1,1),dtype=float)
  nodes =np.empty((OrderPol+1,1),dtype=float)
  weights = np.empty((OrderPol+1,1),dtype=float)
  basis_fun_vec[:,0], alpha_coe[:,0] , beta_coe[:,0] = local_basis_Stieltjes_test(pd,a,b,OrderPol,tol);
  nodes[:,0],weights[:,0] = quad_from_alpha_beta(alpha_coe, beta_coe)
  if Dimension > 0:
    for i in range(Dimension):
      bvec, acoe, bcoe = local_basis_Stieltjes_test(pd,a,b,OrderPol,tol);
      
      np.concatenate((basis_fun_vec,np.expand_dims(bvec, axis=1)),axis = 1)
      np.concatenate((alpha_coe,np.expand_dims(acoe, axis=1)),axis = 1)
      np.concatenate((beta_coe,np.expand_dims(bcoe, axis=1)),axis = 1)
      n,w = quad_from_alpha_beta(acoe, bcoe)
      np.concatenate((nodes,np.expand_dims(n, axis=1)),axis = 1)
      np.concatenate((weights,np.expand_dims(w, axis=1)),axis = 1)
  if Dimension>1:
    NODES1, NODES2 = np.meshgrid(nodes[:],nodes[:])
    NODES_EVAL = [NODES1,NODES2]
    Weights1, Weights2 = meshgrid(weights[0],weights[1])
    Weights = np.prod([Weights1, Weights2],1)
  elif Dimension ==1:
    NODES_EVAL = nodes
    Weights = weights
  print('Run the realizations for')
  for i in range(len(NODES_EVAL)):
      print(f'xi ={NODES_EVAL[i]}')
  #%% What are the corresponding inlet velocities?
  StDev = std
  u1 = StDev
  u2 = 0

  uk = np.zeros((OrderPol+1,1))
  uk[0:2] = [[u0],[u1]]
  if Dimension>1:
    PsiBasis = nD_polynomial_array(Dimension,OrderPol)
  elif Dimension == 1:
      PsiBasis = np.expand_dims(np.asarray([k for k in range(OrderPol+1)]).T,1)
  def poleval_multD(xi, PsiBasis, OrderPol, basis_fun_array):
    pc_xi = np.ones((np.size(xi,0),np.size(PsiBasis,0)))
    for id in range(np.size(PsiBasis,1)):
        nnz_index = np.argwhere(PsiBasis[:,id]>0)
        if np.size(nnz_index)>0:
            for j in range(len(nnz_index)):
              pc_xi[:,nnz_index[j,id]] = pc_xi[:,nnz_index[j,id]]*basis_fun_array[PsiBasis[nnz_index[j,id],id],0](xi[:,id])
    return pc_xi
  basis_evals = poleval_multD(NODES_EVAL, PsiBasis, OrderPol, basis_fun_vec)
  U = basis_evals@uk
  print("-> Run simulations with the following inlet velocities")
  for i in range(len(NODES_EVAL)):
        print(f'U = {U[i]}')
  return U